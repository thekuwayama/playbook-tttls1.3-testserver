# encoding: ascii-8bit
# frozen_string_literal: true

require 'etc'
require 'http/parser'
require 'logger'
require 'socket'
require 'time'
require 'timeout'
require 'tttls1.3'
require 'webrick'

def simple_http_response(body)
  h = <<~HEADER_EOS
    HTTP/1.1 200 OK
    Date: #{Time.now.httpdate}
    Content-Type: text/html
    Content-Length: #{body.length}
    Server: tttls1.3 https server
  HEADER_EOS

  h.gsub(WEBrick::LF, WEBrick::CRLF) + WEBrick::CRLF + body
end

port = ARGV[0] || 4433
http_response_body = File.open('{{ https_server_directory }}/index.html', 'r').read
http_response = simple_http_response(http_response_body)

settings = {
  crt_file: '/etc/letsencrypt/live/{{ domain }}/fullchain.pem',
  key_file: '/etc/letsencrypt/live/{{ domain }}/privkey.pem',
  alpn: ['http/1.1']
}

q = Queue.new
logger = Logger.new(STDERR, Logger::WARN)
# rubocop: disable Metrics/BlockLength
Etc.nprocessors.times do
  Thread.start do
    loop do
      s = q.pop
      Timeout.timeout(1) do
        server = TTTLS13::Server.new(s, settings)
        parser = HTTP::Parser.new

        parser.on_message_complete = proc do
          if !parser.http_method.nil?
            logger.info 'Receive Request'
            server.write(http_response)
            server.close
          else
            logger.warn 'Not Request'
          end
        end

        begin
          server.accept
          parser << server.read until server.eof?
          server.close
        rescue StandardError => e
          logger.warn e
        ensure
          parser.reset!
        end
      end
    rescue Timeout::Error
      logger.warn 'Timeout'
    ensure
      s.close
    end
  end
end
# rubocop: enable Metrics/BlockLength

Socket.tcp_server_loop(port) do |socket, _addr|
  q << socket
end
